<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - src/mapping/state.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>src/mapping/state.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">70.32</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">438</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">60.32</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.31</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">(function(global) {
  &#039;use strict&#039;;
  var State = global.VFDeps.State;
  var Collection = global.VFDeps.Collection;

  function isCollectionOfParent(o, p) {
    if (!p || !p._collections) return;
    for (var name in p._collections) {
      if (p[name] === o.collection) return name + &#039;.&#039; + o.getId();
    }
  }

  function isChildOfParent(o, p) {
    if (!p || !p._children) return;
    for (var name in p._children) {
      if (p[name] === o) return name;
    }
  }

  function isPropOfParent(o, p) {
    if (!p) return;
    for (var name in p) {
      if (p[name] === o) return name;
    }
  }


  function objectPath(state) {
    if (!state) return null;
    var parts = [];


    var f = function(instance) {

      var collectionName = instance.collection ?
                        isCollectionOfParent(instance, instance.collection.parent) :
                        null;
      if (collectionName) {
        parts.unshift(collectionName);
        return f(instance.collection.parent);
      }

      var childName = isChildOfParent(instance, instance.parent);
      if (childName) {
        parts.unshift(childName);
        return f(instance.parent);
      }


      var propName = isPropOfParent(instance, instance.parent);
      if (propName) {
        parts.unshift(propName);
        return f(instance.parent);
      }

      if (instance.parent) f(instance.parent);
    };

    f(state);

    return parts.join(&#039;.&#039;);
  }


  function resolve(path, context) {
    if (!context) throw new Error(&#039;Missing context to solve mapping path&#039;);

    function solver(str) {
      var parts = str.split(&#039;.&#039;);

      var f = function(instance) {
        if (!parts.length) return instance;

        var part = parts.shift();
        if (instance[part] &amp;&amp; instance[part].isCollection) {
          return f(instance[part].get(parts.shift()));
        }
        else if (typeof instance[part] !== &#039;undefined&#039;) {
          return f(instance[part]);
        }
      };
      return f;
    }

    return solver(path)(context);
  }
















  var MappingState = State.extend({
    mappable: {source: [], target: []},

    props: {
      sourceObject: [&#039;state&#039;, true, null],
      sourceProperty: [&#039;string&#039;, true, null],

      targetObject: [&#039;state&#039;, false, null],
      targetProperty: [&#039;string&#039;, false, null],

      transformation: [&#039;any&#039;, false, null]
    },

    session: {
      uiState: {
        type: &#039;string&#039;,
        values: [&#039;&#039;, &#039;dependency&#039;, &#039;dependent&#039;, &#039;focus&#039;, &#039;highlighted&#039;],
        default: &#039;&#039;,
        required: true
      }
    },

    derived: {
      sourcePath: {
        deps: [&#039;sourceObject&#039;, &#039;sourceProperty&#039;],
        fn: function() {
          var objPath = objectPath(this.sourceObject);
          return (objPath ? objPath + &#039;.&#039; : &#039;&#039;) + this.sourceProperty;
        }
      },
      sourceValue: {
        deps: [&#039;sourceObject&#039;, &#039;sourceProperty&#039;],
        fn: function() {
          return this.sourceObject.get(this.sourceProperty);
        }
      },
      sourceObjectType: {
        deps: [&#039;sourceValue&#039;],
        fn: function () {
          return typeof this.sourceValue;
        }
      },

      transformationFunction: {
        deps: [&#039;transformation&#039;],
        fn: function () {
          var noop = function(val){ return val; };

          var fn;
          if (typeof this.transformation === &#039;function&#039;) {
            fn = this.transformation.bind(this);
          }
          else if (typeof this.transformation === &#039;string&#039;) {
            try {
              // not pretty
              eval(&#039;fn = &#039; + this.transformation + &#039;;&#039;);
            }
            catch (e) {
              // not pretty
              console.warn(e);
              fn = noop;
            }
          }
          else {
            fn = noop;
          }

          return fn;
        }
      },
      targetPath: {
        deps: [&#039;targetObject&#039;, &#039;targetProperty&#039;],
        fn: function() {
          if (!this.targetObject || !this.targetProperty) return null;
          var objPath = objectPath(this.targetObject);
          return (objPath ? objPath + &#039;.&#039; : &#039;&#039;) + this.targetProperty;
        }
      },
      targetValue: {
        deps: [&#039;sourceValue&#039;, &#039;targetObject&#039;, &#039;targetProperty&#039;, &#039;transformationFunction&#039;],
        fn: function() {
          if (!this.targetObject || !this.targetProperty) return null;
          return this.transformationFunction.call(this, this.sourceValue);
        }
      }
    },

    objectPath: function(state) {
      return objectPath(state);
    },

    resolve: function(path, context) {
      return resolve(path, context || this.collection.context);
    },

    initialize: function(attrs) {
      if (!attrs.sourceObject || !attrs.sourceProperty) throw new Error(&#039;Missing sourceObject information&#039;);
      this.listenToAndRun(this, &#039;change:targetValue&#039;, this.sourceValueChange);
      this.listenToAndRun(this.sourceObject, &#039;all&#039;, function(evtName) {
        if (evtName === &#039;change:&#039; + this.sourceProperty) {
          this.trigger(&#039;change:sourceProperty&#039;);
        }
      });
    },

    updateInfo: function(scope, fullPath, context) {
      var parts = fullPath.split(&#039;.&#039;);
      var prop = parts.pop();
      var obj = this.resolve(parts.join(&#039;.&#039;), context || this.collection.context);
      var update = {};
      update[scope +&#039;Object&#039;] = obj;
      update[scope +&#039;Property&#039;] = prop;
      // console.info(fullPath, update);
      this.set(update);
    },

    sourceValueChange: function() {
      if (!this.targetObject || !this.targetProperty) return;
      // console.info(&#039;%c%s =&gt; %s changed %s =&gt; %s&#039;, &#039;color:purple;&#039;, this.sourcePath, this.targetPath, this.sourceValue, this.targetValue, this.targetObject);
      this.targetObject.set(this.targetProperty, this.targetValue);
    }
  });



















  var _mappings = new (Collection.extend({
    model: MappingState,

    // has problem with  &#039;id = targetObjectProto._derived[this.mainIndex].fn.call(attrs);&#039; in ampersand-collection
    // mainIndex: &#039;targetPath&#039;,// ensure uniqueness?

    lookup: function(coords, whom) {
      whom = !whom ? &#039;sourceObject&#039; : &#039;targetObject&#039;;
      return _mappings.filter(function(state) {
        return state[whom + &#039;Path&#039;] === coords;
      });
    },

    resolve: function(path, context) {
      return resolve(path, context || this.context);
    },

    objectPath: function(state) {
      return objectPath(state);
    },

    isTarget: function(state, propName) {
      var p = objectPath(state);
      p = (p ? p + &#039;.&#039; : &#039;&#039;) + propName;
      return this.models.find(function(mapping) {
        return mapping.targetPath === p;
      });
    },

    isSource: function(state, propName) {
      var p = objectPath(state) + propName;
      return this.models.find(function(mapping) {
        return mapping.sourcePath === p;
      });
    },

    sourceSuggestions: function(origin) {
      var results = [];
      if (!origin || typeof origin !== &#039;object&#039;) return results;

      var kepts = [];
      if (origin.mappable &amp;&amp; origin.mappable.source) {
        kepts = (origin.mappable.source || []);
      }

      function filterKeys(key) {
        var excluded = [
          &#039;mappable&#039;,
          &#039;parent&#039;,
          &#039;collection&#039;,
          origin.idAttribute,
          origin.typeAttribute
        ];
        return excluded.indexOf(key) &lt; 0 &amp;&amp; kepts.indexOf(key) &gt; -1;
      }

      var proto = origin.constructor &amp;&amp; origin.constructor.prototype ? origin.constructor.prototype : {};
      var propNames = Object.keys(proto._definition || {});
      var derivedNames = Object.keys(proto._derived || {});
      var childNames = Object.keys(proto._children || {});
      var collectionNames = Object.keys(proto._collections || {});

      propNames.concat(derivedNames, childNames)
        .filter(filterKeys)
        .forEach(function(key) {
          var sub = this.sourceSuggestions(origin[key]);
          if (!sub.length) {
            if (childNames.indexOf(key) &lt; 0) {
              results.push(key);
            }
            return;
          }

          results = results.concat(sub.map(function(name) {
            return key + &#039;.&#039; + name;
          }));
        }, this);

      collectionNames
        .filter(filterKeys)
        .forEach(function(collectionName) {
          origin[collectionName].forEach(function(model) {
            var id = model.getId();
            var suggestions = this.sourceSuggestions(model);
            results = results.concat(suggestions.filter(function(v) { return !!v; }).map(function(name) {
              return collectionName + &#039;.&#039; + id + &#039;.&#039; + name;
            }));
          }, this);
        }, this);

      return results;
    },

    targetSuggestions: function(origin) {
      var results = [];
      if (!origin || typeof origin !== &#039;object&#039;) return results;

      var kepts = [];
      if (origin.mappable &amp;&amp; origin.mappable.target) {
        kepts = (origin.mappable.target || []);
      }

      function filterKeys(key) {
        var excluded = [
          &#039;mappable&#039;,
          &#039;parent&#039;,
          &#039;collection&#039;,
          origin.idAttribute,
          origin.typeAttribute
        ];
        return excluded.indexOf(key) &lt; 0 &amp;&amp; kepts.indexOf(key) &gt; -1;
      }

      var proto = origin.constructor &amp;&amp; origin.constructor.prototype ? origin.constructor.prototype : {};
      var propNames = Object.keys(proto._definition || {});
      var childNames = Object.keys(proto._children || {});
      var collectionNames = Object.keys(proto._collections || {});

      propNames.concat(childNames)
        .filter(filterKeys)
        .forEach(function(key) {
          var sub = this.targetSuggestions(origin[key]);
          if (!sub.length) {
            if (childNames.indexOf(key) &lt; 0) {
              results.push(key);
            }
            return;
          }

          results = results.concat(sub.map(function(name) {
            return key + &#039;.&#039; + name;
          }));
        }, this);

      collectionNames
        .filter(filterKeys)
        .forEach(function(collectionName) {
          origin[collectionName].forEach(function(model) {
            var id = model.getId();
            var suggestions = this.targetSuggestions(model);
            results = results.concat(suggestions.filter(function(v) { return !!v; }).map(function(name) {
              return collectionName + &#039;.&#039; + id + &#039;.&#039; + name;
            }));
          }, this);
        }, this);

      return results;
    },

    import: function(data, context) {
      context = context || this.context;
      if (!context) throw new Error(&#039;mappings.import() requires a context&#039;);

      this.add(data.map(function(item) {
        var source = item.source.split(&#039;.&#039;);
        var target = item.target.split(&#039;.&#039;);

        return {
          sourceObject: this.resolve(source.slice(0, -1).join(&#039;.&#039;), context) || context,
          sourceProperty: source.pop(),
          targetObject: this.resolve(target.slice(0, -1).join(&#039;.&#039;), context) || context,
          targetProperty: target.pop(),
          transformation: item.transform
        };
      }, this));
    },

    export: function() {
      return this.map(function(item) {
        return {
          source: item.sourcePath,
          target: item.targetPath,
          transform: (item.transformation || &#039;&#039;).toString()
        };
      });
    },

    remove: function(models) {
      models = Array.isArray(models) ? models : [models];

      models.forEach(function(modelOrId) {
        var model = typeof modelOrId === &#039;string&#039; ? this.get(modelOrId) : modelOrId;
        if (!model) {
          console.info(&#039;could not determine the model for&#039;, modelOrId);
          return;
        }
        model.stopListening();
      }, this);

      return Collection.prototype.remove.apply(this, arguments);
    }
  }))();

  module.exports = _mappings;
})(typeof window !== &#039;undefined&#039; ? window : self);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
