{"version":3,"sources":["webpack:///webpack/bootstrap e9aefe96549ae3306346","webpack:///./web-worker.js"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;ACvFA;AACA;AACA;AACA,mDAIA;AACA,mDAEA;AACA,mDASA;AACA,mDAEA;AACA,mDAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;;;AAGA;AACA,wDAAwD,WAAW;AACnE;AACA,CAAC;;;AAGD;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;;AAGA;AACA;AACA,CAAC;;;AAGD;AACA;AACA,iCAAiC,WAAW;AAC5C,4CAA4C,iBAAiB,EAAE;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD,SAAS;AACT;AACA,sCAAsC,WAAW;AACjD,SAAS;AACT,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,+BAA+B;AACrE,SAAS;AACT;AACA,sCAAsC,6BAA6B;AACnE,SAAS;AACT,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D,sCAAsC,+BAA+B;AACrE,SAAS;AACT;AACA,sCAAsC,6BAA6B;AACnE,SAAS;AACT,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD,6BAA6B,aAAa;AAC1C,GAAG;;;AAGH;AACA;AACA,GAAG;;;;AAIH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;;;AAIH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;;;AAIH;AACA;AACA,+BAA+B,iBAAiB;AAChD,GAAG;AACH;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,GAAG;AACH;AACA;AACA,kCAAkC,WAAW;AAC7C,GAAG;AACH;AACA;AACA,GAAG;;;;;;AAMH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;;;;;AAMH;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,oDAAoD,aAAa;AACjE,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;;;;AAMA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD,CAAC;AACD,CAAC;AACD,CAAC;AACD,CAAC,iE","file":"worker-build.js","sourcesContent":[" \tthis[\"webpackChunk\"] = function webpackChunkCallback(chunkIds, moreModules) {\n \t\tfor(var moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\twhile(chunkIds.length)\n \t\t\tinstalledChunks[chunkIds.pop()] = 1;\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded chunks\n \t// \"1\" means \"already loaded\"\n \tvar installedChunks = {\n \t\t5: 1\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\t// \"1\" is the signal for \"already loaded\"\n \t\tif(!installedChunks[chunkId]) {\n \t\t\timportScripts(\"\" + chunkId + \".worker-build.js\");\n \t\t}\n \t\treturn Promise.resolve();\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 17);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e9aefe96549ae3306346","/* jshint worker:true */\n'use strict';\nvar worker = self;\nrequire.ensure([\n  'lodash.assign',\n  'ampersand-state',\n  'ampersand-collection'\n], function() {\nrequire.ensure([\n  './mapping/data',\n], function() {\nrequire.ensure([\n  './layer/state',\n  './layer/svg/state',\n  './layer/img/state',\n  './layer/txt/state',\n  './layer/p5/state',\n  './layer/threejs/state',\n  './layer/video/state',\n  './layer/canvas/state',\n], function() {\nrequire.ensure([\n  './screen/state',\n], function() {\nrequire.ensure([\n  './utils/resolve',\n  './signal/collection'\n], function() {\n// ---------------------------------------------------------------\nvar resolve = require('./utils/resolve');\nvar fromYaml = require('./utils/yaml-to-setup');\n\nvar Mappings = require('./mapping/data');\n\nvar ScreenState = require('./screen/state');\nworker.screen = new ScreenState();\n\nworker.layers = worker.screen.layers;\n\nvar SignalCollection = require('./signal/collection');\nworker.signals = new SignalCollection({\n  parent: worker.screen\n});\nworker.signals.listenTo(worker.screen.clock, 'change:frametime', function(...args) {\n  worker.signals.trigger('change:frametime', ...args);\n});\nvar localForage = require('./storage');\n\n\nlocalForage.installSetups(function(err) {\n  if (err) return emitCommand('storageSetupInstalled', {error: err});\n  emitCommand('storageSetupInstalled');\n});\n\n\nvar __dataContext = {\n  frametime: 0,\n  firstframetime: 0,\n  audio: {},\n  layers: worker.layers,\n  signals: worker.signals\n};\n\n\nworker.mappings = new Mappings([], {\n  context: __dataContext\n});\n\n\nfunction signature(fn) {\n  var args = fn.toString().match('function[^(]*\\\\(([^)]*)\\\\)');\n  if (!args || !args[1].trim()) { return []; }\n  return args[1].split(',').map(function(a){ return a.trim(); });\n}\n\nvar signatures = {};\nfunction registerCommand(commandName, command) {\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      command = arguments[0];\n      commandName = command.name;\n    }\n    else {\n      command = commands[arguments[0]];\n    }\n  }\n  else if (typeof command !== 'function') {\n    command = commands[commandName];\n  }\n  signatures[commandName] = signature(command);\n}\n\n\n\nfunction emitCommand(name, payload) {\n  worker.postMessage({\n    command: name,\n    payload: payload\n  });\n}\n\n\nvar screens = {};\nvar channel = new BroadcastChannel('spike');\nfunction broadcastCommand(name, payload) {\n  channel.postMessage({\n    command: name,\n    payload: payload\n  });\n}\n\n\n\n/******************************************************\\\n * Worker   clock                                     *\n\\******************************************************/\nvar _fps = 60;\nvar _prev = performance.now();\nvar _frameMillis = 1000 / _fps;\nvar _internalTimeout;\nvar _frameCounter = 0;\nvar _samplesCount = _fps * 2;\nvar _prevSamples = _prev;\n\nfunction _animate() {\n  __dataContext.frametime = worker.screen.clock.refresh().frametime;\n\n  emitCommand('updateSignals', {\n    signals: worker.signals.serialize().filter(o => o.name)\n  });\n\n  broadcastCommand('updateLayers', {\n    layers: worker.layers.serialize()\n  });\n\n\n  var _now = performance.now();\n  var elapsed = _now - _prev;\n  var timeDiff = _frameMillis - (elapsed - _frameMillis);\n  _prev = _now;\n  _internalTimeout = setTimeout(_animate, timeDiff);\n\n  _frameCounter++;\n  if (_frameCounter === _samplesCount) {\n    // inform the controller of the health of the worker\n    emitCommand('health', {\n      frametime: worker.screen.frametime,\n      elapsed: _now - _prevSamples,\n      fps: _fps,\n      frameCounter: _frameCounter,\n      samplesCount: _samplesCount\n    });\n\n    _frameCounter = 0;\n    _prevSamples = _now;\n  }\n}\n_internalTimeout = setTimeout(_animate, _frameMillis);\n\n\n// var _bootstrapTime = Date.now();\n// var _executedCommands = [];\n// var _previousCommandIndex = 0;\n\n// setInterval(function() {\n//   if (_previousCommandIndex < _executedCommands.length) {\n//     console.info('send %s timelineCommands', _executedCommands.length - _previousCommandIndex);\n//     emitCommand('timelineCommands', {\n//       commands: _executedCommands.slice(_previousCommandIndex, _executedCommands.length)\n//     });\n//     _previousCommandIndex = _executedCommands.length;\n//   }\n// }, 100);\n\n\n/******************************************************\\\n * Screen registration                                *\n\\******************************************************/\nchannel.addEventListener('message', function(evt) {\n  var command = evt.data.command;\n  if (command !== 'register') return;\n\n  var payload = evt.data.payload;\n  if (screens[payload.id]) {\n    return;\n  }\n\n  screens[payload.id] = payload.id;\n});\n\n\n\n/******************************************************\\\n * Worker commands                                    *\n\\******************************************************/\nvar commands = {\n  play: function() {\n    worker.screen.clock.play();\n  },\n  pause: function() {\n    worker.screen.clock.pause();\n  },\n  stop: function() {\n    worker.screen.clock.stop();\n  },\n  setBPM: function(bpm) {\n    worker.screen.clock.bpm = bpm;\n  },\n\n  storageKeys: function() {\n    localForage\n      .keys()\n        .then(function(keys) {\n          emitCommand('storageKeys', {keys: keys});\n        })\n        .catch(function(err) {\n          emitCommand('storageKeys', {error: err});\n        });\n  },\n  storageSave: function(setupId) {\n    var setup = {\n      layers: worker.layers.serialize(),\n      signals: worker.signals.serialize(),\n      mappings: worker.mappings.serialize()\n    };\n\n    localForage\n      .setItem(setupId, setup)\n        .then(function() {\n          emitCommand('storageSave', {setup: setup, setupId: setupId});\n        })\n        .catch(function(err) {\n          emitCommand('storageSave', {error: err, setupId: setupId});\n        });\n  },\n  storageLoad: function(setupId) {\n    localForage\n      .getItem(setupId)\n        .then(function(setup) {\n          worker.layers.reset(setup.layers);\n          worker.signals.reset(setup.signals);\n          worker.mappings.reset(setup.mappings);\n\n          setup = {\n            signals: worker.signals.serialize(),\n            mappings: worker.mappings.serialize(),\n            layers: worker.layers.serialize()\n          };\n          broadcastCommand('bootstrap', {layers: setup.layers});\n          emitCommand('storageLoad', {setup: setup, setupId: setupId});\n        })\n        .catch(function(err) {\n          emitCommand('storageLoad', {error: err, setupId: setupId});\n        });\n  },\n\n  yamlLoad: function(yamlStr) {\n    var setup = fromYaml(yamlStr);\n    worker.layers.reset(setup.layers);\n    worker.signals.reset(setup.signals);\n    worker.mappings.reset(setup.mappings);\n\n    setup = {\n      signals: worker.signals.serialize(),\n      mappings: worker.mappings.serialize(),\n      layers: worker.layers.serialize()\n    };\n    broadcastCommand('bootstrap', {layers: setup.layers});\n    emitCommand('yamlLoad', {setup: setup});\n  },\n\n\n  midi: function(deviceName, property, velocity) {\n    worker.mappings.processMIDI(deviceName, property, velocity);\n  },\n\n\n\n  heartbeat: function(audio) {\n    worker.audio = audio;\n    broadcastCommand('heartbeat', {\n      clock: worker.screen.clock.serialize(),\n      audio: audio\n    });\n  },\n\n\n\n  propChange: function(path, property, value) {\n    var obj = resolve(path, __dataContext);\n    if (!obj) return;\n    if (obj[property] && obj[property].isCollection) {\n      return obj[property].set(Array.isArray(value) ? value : [value]);\n    }\n    obj.set(property, value);\n  },\n\n\n\n  addMapping: function(mapping) {\n    worker.mappings.add(mapping);\n    emitCommand('addMapping', {mapping: mapping});\n  },\n  updateMapping: function(mapping) {\n    var state = worker.mappings.get(mapping.name);\n    if (state) state.set(mapping);\n    emitCommand('updateMapping', {mapping: mapping});\n  },\n  removeMapping: function(name) {\n    worker.mappings.remove(name);\n    emitCommand('removeMapping', {name: name});\n  },\n  resetMappings: function(mappings) {\n    worker.mappings.import(mappings, true);\n  },\n\n\n\n\n\n  resetSignals: function(signals) {\n    worker.signals.reset(signals);\n    emitCommand('resetSignals', {\n      signals: signals\n    });\n  },\n  addSignal: function(signal) {\n    worker.signals.add(signal);\n    emitCommand('addSignal', {\n      signal: signal\n    });\n  },\n  removeSignal: function(signalName) {\n    var collection = worker.signals;\n    collection.remove(collection.get(signalName));\n    emitCommand('removeSignal', {\n      signalName: signalName\n    });\n  },\n  updateSignal: function(signal, signalName) {\n    var state = worker.signals.get(signalName);\n    state.set(signal);\n    emitCommand('updateSignal', {\n      signalName: signalName,\n      signal: signal\n    });\n  },\n  updateSignals: function(signals) {\n    worker.signals.set(signals);\n    emitCommand('updateSignals', {\n      signals: signals\n    });\n  },\n\n\n\n\n\n  resetLayers: function(layers) {\n    worker.layers.reset(layers);\n\n    broadcastCommand('resetLayers', {\n      layers: layers\n    });\n  },\n  addLayer: function(layer) {\n    worker.layers.add(layer);\n\n    broadcastCommand('addLayer', {\n      layer: layer\n    });\n  },\n  removeLayer: function(layerName) {\n    var collection = worker.layers;\n    collection.remove(collection.get(layerName));\n\n    broadcastCommand('removeLayer', {\n      layerName: layerName\n    });\n  },\n  updateLayer: function(layer, broadcast) {\n    var state = worker.layers.get(layer.name);\n    state.set(layer);\n    if (broadcast) broadcastCommand('updateLayer', {layer: layer});\n  },\n\n  addParameter: function(path, parameter) {\n    var obj = resolve(path, __dataContext);\n    if (!obj || !obj.parameters) return;\n    obj.parameters.add(parameter);\n  }\n};\n\n\n\nObject.keys(commands).forEach(registerCommand);\n\n\n\n\n\nworker.addEventListener('message', function(evt) {\n  var eventId = evt.data.eventId;\n\n  var commandName = evt.data.command;\n  var command = commands[commandName];\n\n\n  if (typeof command !== 'function') {\n    return worker.postMessage({\n      type: 'error',\n      command: commandName,\n      message: 'Unknown command \"' + commandName + '\"',\n      eventId: eventId\n    });\n  }\n\n  if (!signatures[commandName]) {\n    return worker.postMessage({\n      type: 'result',\n      command: commandName,\n      payload: command(evt.data),\n      eventId: eventId\n    });\n  }\n\n  var commandArgs = signatures[commandName].map(function(argName) {\n    return evt.data.payload[argName];\n  });\n\n  var result = command.apply(worker, commandArgs);\n  if (!eventId) return;\n  worker.postMessage({\n    type: 'result',\n    command: commandName,\n    payload: result,\n    eventId: eventId\n  });\n}, {\n  passive: true,\n  capture: false\n});\n\nworker.layers.on('emitCommand', emitCommand);\nworker.layers.on('broadcastCommand', broadcastCommand);\n// --------------------------------------------------------------\n}, 'worker-deps');\n}, 'screen-state');\n}, 'layer-state');\n}, 'mapping-data');\n}, 'ampersand-data');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./web-worker.js\n// module id = 17\n// module chunks = 5"],"sourceRoot":""}